import { Serializable, toDeserialized, toSerialized } from "../shared.js";
import type { Result } from "../types.js";
import { Semaphore } from "./semaphore.js";
import { SharedJsonBuffer } from "../json_buffer.js";
declare class ChannelInternals<T> extends Serializable {
    state: Int32Array<SharedArrayBuffer>;
    items: SharedJsonBuffer<(T | null)[]>;
    sendLock: Semaphore;
    recvLock: Semaphore;
    itemsAvailable: Semaphore;
    slotsAvailable: Semaphore;
    constructor(state: Int32Array<SharedArrayBuffer>, items: SharedJsonBuffer<(T | null)[]>, sendLock: Semaphore, recvLock: Semaphore, itemsAvailable: Semaphore, slotsAvailable: Semaphore);
    write(value: T): void;
    read(): T | null;
    isClosed(): boolean;
    hasReceivers(): boolean;
    [toSerialized](): readonly [readonly [SharedArrayBuffer, import("../types.ts").Envelope, import("../types.ts").Envelope, import("../types.ts").Envelope, import("../types.ts").Envelope, import("../types.ts").Envelope], Transferable[]];
    static [toDeserialized](data: ReturnType<ChannelInternals<any>[typeof toSerialized]>[0]): ChannelInternals<unknown>;
}
declare abstract class ChannelHandle<T> extends Serializable implements Disposable {
    protected internals: ChannelInternals<T>;
    protected disposed: boolean;
    constructor(internals: ChannelInternals<T>);
    protected abstract get disposeError(): Error;
    protected checkDisposed(): {
        ok: false;
        error: Error;
    } | null;
    [toSerialized](): [import("../types.ts").Envelope, Transferable[]];
    abstract close(): void;
    abstract [Symbol.dispose](): void;
}
export declare class Sender<T> extends ChannelHandle<T> {
    protected get disposeError(): Error;
    clone(): Sender<T>;
    send(value: T): Promise<Result<void, Error>>;
    blockingSend(value: T): Result<void, Error>;
    close(): void;
    [Symbol.dispose](): void;
    static [toDeserialized](obj: ReturnType<Sender<any>[typeof toSerialized]>[0]): Sender<unknown>;
}
export declare class Receiver<T> extends ChannelHandle<T> {
    protected get disposeError(): Error;
    clone(): Receiver<T>;
    recv(): Promise<Result<T, Error>>;
    blockingRecv(): Result<T, Error>;
    [Symbol.asyncIterator](): AsyncGenerator<T, void, void>;
    close(): void;
    [Symbol.dispose](): void;
    static [toDeserialized](obj: ReturnType<Receiver<any>[typeof toSerialized]>[0]): Receiver<unknown>;
}
export declare function channel<T>(capacity?: number): [Sender<T>, Receiver<T>];
export {};
